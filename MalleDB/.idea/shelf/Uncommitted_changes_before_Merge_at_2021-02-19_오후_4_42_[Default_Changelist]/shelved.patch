Index: src/main/java/db/MalleDB.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package db;\r\n\r\nimport connectors.Cassandra;\r\nimport connectors.LevelDB;\r\nimport connectors.MySQL;\r\nimport connectors.Redis;\r\nimport interfaces.SubDB;\r\nimport util.*;\r\nimport util.HashMap;\r\n\r\nimport java.io.*;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.*;\r\n\r\npublic class MalleDB implements interfaces.MalleDB {\r\n\r\n    private SubDB metadb;\r\n    private SubDB blockdb;\r\n    private SubDB mdb;\r\n    private SubDB bdb;\r\n    private SubDB tdb;\r\n    private boolean usingOneSubDB = false;\r\n    private String prefix = \"123456\";\r\n\r\n    /*\r\n        public static void main(String[] args) {\r\n\r\n           // String key = generateRandomString(20);\r\n           // System.out.println(\"Before: \" + key);\r\n\r\n            //byte[] arr = key.getBytes();\r\n            //String key1 = new String(arr);\r\n\r\n            //System.out.println(\"After: \" + key1);\r\n\r\n\r\n            MalleDB malleDB = new MalleDB();\r\n            Options options = new Options(Options.DB_TYPE.MYSQL, Options.DB_TYPE.CASSANDRA, Options.DB_TYPE.LEVELDB);\r\n            malleDB.init(options);\r\n            malleDB.create();\r\n\r\n            //4294304\r\n\r\n            String key = generateRandomString(20);\r\n            String value = generateRandomString(500);\r\n\r\n            System.out.println(\"Key: \" + key);\r\n            System.out.println(\"Value: \" + value);\r\n\r\n            malleDB.insert(key, value);\r\n\r\n\r\n            malleDB.read(key);\r\n\r\n           // String key = \"E1O1IByghZN0ryG7raPf\";\r\n            malleDB.delete(key);\r\n\r\n\r\n            malleDB.close();\r\n\r\n        }\r\n    */\r\n    //Initialize with default configuration\r\n    @Override\r\n    public Status init() {\r\n        return init(new Options());\r\n    }\r\n\r\n    //Initialize with custom configuration\r\n    @Override\r\n    public Status init(Options options) {\r\n\r\n        if (Options.SUB_DB == Options.DB_TYPE.MYSQL) {\r\n            metadb = new MySQL();\r\n        } else if (Options.SUB_DB == Options.DB_TYPE.LEVELDB) {\r\n            metadb = new LevelDB();\r\n        } else if (Options.SUB_DB == Options.DB_TYPE.CASSANDRA) {\r\n            metadb = new Cassandra();\r\n        } else if (Options.SUB_DB == Options.DB_TYPE.REDIS) {\r\n            metadb = new Redis();\r\n        }\r\n\r\n        metadb.init();\r\n\r\n\r\n        if (options.isUsingDefault()) {\r\n            usingOneSubDB = true;\r\n            if (Options.SUB_DB == Options.DB_TYPE.MYSQL) {\r\n                blockdb = new MySQL();\r\n            } else if (Options.SUB_DB == Options.DB_TYPE.LEVELDB) {\r\n                blockdb = new LevelDB();\r\n            } else if (Options.SUB_DB == Options.DB_TYPE.CASSANDRA) {\r\n                blockdb = new Cassandra();\r\n            } else if (Options.SUB_DB == Options.DB_TYPE.REDIS) {\r\n                blockdb = new Redis();\r\n            }\r\n\r\n            blockdb.init();\r\n\r\n            mdb = null;\r\n            bdb = null;\r\n            tdb = null;\r\n\r\n        } else {\r\n\r\n            if (options.getDbMedium() == Options.DB_TYPE.MYSQL) {\r\n                mdb = new MySQL();\r\n            } else if (options.getDbMedium() == Options.DB_TYPE.LEVELDB) {\r\n                mdb = new LevelDB();\r\n            } else {\r\n                mdb = new Cassandra();\r\n            }\r\n\r\n            if (options.getDbBlob() == Options.DB_TYPE.MYSQL) {\r\n                bdb = new MySQL();\r\n            } else if (options.getDbBlob() == Options.DB_TYPE.LEVELDB) {\r\n                bdb = new LevelDB();\r\n            } else {\r\n                bdb = new Cassandra();\r\n            }\r\n\r\n            if (options.getDbTiny() == Options.DB_TYPE.MYSQL) {\r\n                tdb = new MySQL();\r\n            } else if (options.getDbTiny() == Options.DB_TYPE.LEVELDB) {\r\n                tdb = new LevelDB();\r\n            } else {\r\n                tdb = new Cassandra();\r\n            }\r\n\r\n            metadb.init();\r\n            mdb.init();\r\n            bdb.init();\r\n            tdb.init();\r\n            blockdb = null;\r\n        }\r\n        return Status.OK;\r\n    }\r\n\r\n    //Create databses and tables\r\n    @Override\r\n    public Status create() {\r\n        metadb.create();\r\n        if (usingOneSubDB) {\r\n            blockdb.create();\r\n        } else {\r\n            mdb.create();\r\n            bdb.create();\r\n            tdb.create();\r\n        }\r\n        return Status.OK;\r\n    }\r\n\r\n    //Close the connection\r\n    @Override\r\n    public Status close() {\r\n        metadb.close();\r\n        if (usingOneSubDB) {\r\n            blockdb.close();\r\n        } else {\r\n            mdb.close();\r\n            bdb.close();\r\n            tdb.close();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    //Insert data\r\n    @Override\r\n    public Status insert(String key, String value) {\r\n\r\n        //Initialize the variables starts\r\n        String chunk;\r\n        int order;\r\n        Item meta;\r\n        ArrayList<Item>[] blocks = new ArrayList[Options.bCOUNTER];\r\n        for (int i = 0; i < Options.bCOUNTER; i++) {\r\n            blocks[i] = new ArrayList<>();\r\n        }\r\n        int[] counters = new int[Options.bCOUNTER];\r\n        //Initialize the variables ends\r\n\r\n        //Memtable managements part starts\r\n        for (int i = 0; i < Options.bCOUNTER; i++) {\r\n            //check if the value size smaller than the block but the block is not tiny\r\n            if (value.length() < Options.BLOCKS[i] && i != Options.bCOUNTER - 1) {\r\n                continue;\r\n            }\r\n            //Initialize the order to 0\r\n            order = 0;\r\n            //Repeat while the value size is not 0\r\n            while (!value.equals(\"\")) {\r\n                order++;\r\n                //Check if the block is tiny and value size is smaller\r\n                if (i == Options.bCOUNTER - 1 && value.length() <= Options.BLOCKS[i]) {\r\n                    chunk = value;\r\n                    value = \"\";\r\n                } else { //Otherwise\r\n                    //Break the while if the value size is smaller\r\n                    if (value.length() < Options.BLOCKS[i]) {\r\n                        order--;\r\n                        break;\r\n                    }\r\n                    //Initialize the chunk as the block size\r\n                    chunk = value.substring(0, Options.BLOCKS[i]);\r\n                    //Update the value\r\n                    value = value.substring(Options.BLOCKS[i]);\r\n                }\r\n                //Add new block to Memtable\r\n                blocks[i].add(new Item(order, i + 1, key, chunk));\r\n            }\r\n            //Update metadata counter\r\n            counters[i] = order;\r\n        }\r\n        //Memtable managements part ends\r\n\r\n        //Database part starts\r\n        //Initialize and insert metadata\r\n        meta = new Item(key, counters);\r\n        metadb.insert(meta);\r\n\r\n        //Insert to databases\r\n        if (usingOneSubDB) {\r\n            for (int i = 0; i < Options.bCOUNTER; i++) {\r\n                for (int j = 0; j < blocks[i].size(); j++) {\r\n                    blockdb.insert(blocks[i].get(j));\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = 0; i < blocks[0].size(); i++) {\r\n                mdb.insert(blocks[0].get(i));\r\n            }\r\n            for (int i = 0; i < blocks[1].size(); i++) {\r\n                bdb.insert(blocks[1].get(i));\r\n            }\r\n            for (int i = 0; i < blocks[2].size(); i++) {\r\n                tdb.insert(blocks[2].get(i));\r\n            }\r\n        }\r\n        //Database part ends\r\n\r\n        blockdb.flush();    // To prevent Data is remained.\r\n\r\n        return Status.OK;\r\n    }\r\n\r\n    /*\r\n    @Override\r\n    public Status insert(List<String> keys, List<String> values) {\r\n\r\n        String chunk;\r\n        int order;\r\n        List<Item> metaList = new ArrayList<>();\r\n        ArrayList<Item>[] blocks = new ArrayList[Options.bCOUNTER];\r\n        int[] counters = new int[Options.bCOUNTER];\r\n\r\n        for(int n = 0; n < values.size(); n++) {\r\n            //TODO: implement\r\n        }\r\n\r\n        for(int i = 0; i < metaList.size(); i++){\r\n            metadb.insert(metaList.get(i));\r\n        }\r\n        for(int i = 0; i < Options.bCOUNTER; i++){\r\n            for (int j = 0; j < blocks[i].size(); j++)\r\n                blockdb.insert(blocks[i].get(j));\r\n        }\r\n        return Status.OK;\r\n    }\r\n*/\r\n    public Status insertMetaFile(MetaFile newmeta) {\r\n        String key;\r\n        String metaInfo;\r\n        metaInfo = newmeta.toString();\r\n        key = prefix + newmeta.getKey();//change random generate key\r\n        return insert(key, metaInfo);\r\n    }\r\n\r\n    public Status updateMetaFile(String key, MetaFile newmeta) {\r\n        //뉴 메타 파일의 정보에서 기존 메타파일과 동일점 찾아서 업데이트\r\n        deleteMetaFile(key);\r\n        String metaInfo = newmeta.toString();\r\n        return insert(key, metaInfo);\r\n    }\r\n\r\n    public Status deleteMetaFile(String key) {\r\n        return delete(key);\r\n    }\r\n\r\n    public MetaFile readMetaFile(String key) {\r\n        String value = read(key).getValue();\r\n        MetaFile metaFile = new MetaFile();\r\n        metaFile.Stringto(value);\r\n        return metaFile;\r\n    }\r\n\r\n    public Status insertFile(String filename) {\r\n        System.out.println(\"Inserting File : \" + filename);\r\n        String value = encoder(filename);\r\n        return insert(filename, value);\r\n    }\r\n\r\n    public Status readFile(String filename) {\r\n        System.out.println(\"Reading Fiile : \" + filename);\r\n        Status status = read(filename);\r\n        if (status.isOk()) {\r\n            String value = status.getValue();\r\n            decoder(value, filename);\r\n            return Status.OK;\r\n        }\r\n        return Status.ERROR;\r\n    }\r\n\r\n    public void updateFile(String filename){\r\n        deleteFile(filename);\r\n        insertFile(filename);\r\n    }\r\n\r\n    public void deleteFile(String filename){\r\n        delete(filename);\r\n    }\r\n\r\n    private String encoder(String imagePath) {\r\n        String base64Image = \"\";\r\n        byte imageData[] = {};\r\n        File file = new File(imagePath);\r\n        try (FileInputStream imageInFile = new FileInputStream(file)) {\r\n            // Reading a Image file from file system\r\n            imageData = new byte[(int) file.length()];\r\n            BufferedInputStream bis = new BufferedInputStream(imageInFile);\r\n            int size = bis.read(imageData);\r\n            //base64Image = Base64.getEncoder().encodeToString(imageData);\r\n        } catch (FileNotFoundException e) {\r\n            System.out.println(\"Image not found\" + e);\r\n        } catch (IOException ioe) {\r\n            System.out.println(\"Exception while reading the Image \" + ioe);\r\n        }\r\n        // return base64Image;\r\n        return new String(imageData);\r\n    }\r\n\r\n    private void decoder(String value, String pathFile) {\r\n        try (FileOutputStream imageOutFile = new FileOutputStream(pathFile)) {\r\n            // Converting a Base64 String into Image byte array\r\n            //byte[] imageByteArray = Base64.getDecoder().decode(base64Image);\r\n            System.out.println(\"Creating File\");\r\n            BufferedOutputStream bos = new BufferedOutputStream(imageOutFile);\r\n            bos.write(value.getBytes());\r\n            bos.flush();\r\n        } catch (FileNotFoundException e) {\r\n            System.out.println(\"Image not found\" + e);\r\n        } catch (IOException ioe) {\r\n            System.out.println(\"Exception while reading the Image \" + ioe);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Status read(String key) {\r\n        //Initialize the Item\r\n        Item item = new Item();\r\n        item.setKey(key);\r\n        item = metadb.readMeta(item);\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        //Read each block from the sub database\r\n        if (usingOneSubDB) {\r\n            for (int i = 0; i < Options.bCOUNTER; i++) {\r\n                List<Item> blocks = blockdb.readAll(Options.TABLES_MYSQL[i], item);\r\n                for (Item block : blocks) {\r\n                    //Append with the value\r\n                    sb.append(block.getValue());\r\n                }\r\n            }\r\n        } else {\r\n            List<Item> mblocks = mdb.readAll(Options.TABLES_MYSQL[0], item);\r\n            for (Item block : mblocks) {\r\n                sb.append(block.getValue());\r\n            }\r\n\r\n            List<Item> bblocks = bdb.readAll(Options.TABLES_MYSQL[1], item);\r\n            for (Item block : bblocks) {\r\n                sb.append(block.getValue());\r\n            }\r\n\r\n            List<Item> tblocks = tdb.readAll(Options.TABLES_MYSQL[2], item);\r\n            for (Item block : tblocks) {\r\n                sb.append(block.getValue());\r\n            }\r\n        }\r\n        System.out.println(\"Read Value: \" + sb.toString());\r\n        return new Status(\"READ_OK\", \"Success\", key, sb.toString());\r\n    }\r\n\r\n    @Override\r\n    public Status update(String key, String value) {\r\n        delete(key);\r\n        return insert(key, value);\r\n    }\r\n\r\n    @Override\r\n    public Status delete(String key) {\r\n        Item item = new Item();\r\n        item.setKey(key);\r\n        item = metadb.readMeta(item);\r\n\r\n        if (usingOneSubDB) {\r\n          /*  for (int i = 0; i < Options.bCOUNTER; i++) {\r\n                if (item.getCounters()[i] > 0) {\r\n                    blockdb.delete(Options.TABLES_MYSQL[i], item);\r\n                    System.out.println(\"Block deleted...\");\r\n                }\r\n            }*/\r\n            blockdb.deleteAll(item);\r\n        } else {\r\n            if (item.getCounters()[0] > 0) {\r\n                mdb.delete(Options.TABLES_MYSQL[0], item);\r\n            }\r\n            if (item.getCounters()[1] > 0) {\r\n                bdb.delete(Options.TABLES_MYSQL[1], item);\r\n            }\r\n            if (item.getCounters()[2] > 0) {\r\n                tdb.delete(Options.TABLES_MYSQL[2], item);\r\n            }\r\n        }\r\n        metadb.delete(Options.TABLE_META_MYSQL, item);\r\n        System.out.println(\"Meta deleted...\");\r\n        return Status.OK;\r\n    }\r\n\r\n    static String generateRandomString(int n) {\r\n\r\n        // chose a Character random from this String\r\n        String AlphaNumericString = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n                + \"0123456789\"\r\n                + \"abcdefghijklmnopqrstuvxyz\";\r\n\r\n        // create StringBuffer size of AlphaNumericString\r\n        StringBuilder sb = new StringBuilder(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n\r\n            // generate a random number between\r\n            // 0 to AlphaNumericString Optionsiable length\r\n            int index\r\n                    = (int) (AlphaNumericString.length()\r\n                    * Math.random());\r\n\r\n            // add Character one by one in end of sb\r\n            sb.append(AlphaNumericString\r\n                    .charAt(index));\r\n        }\r\n\r\n        return sb.toString();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/db/MalleDB.java b/src/main/java/db/MalleDB.java
--- a/src/main/java/db/MalleDB.java	(revision 0db4d065d62a065d831221942b5be5d6910a7d20)
+++ b/src/main/java/db/MalleDB.java	(date 1613715589426)
@@ -164,6 +164,26 @@
         return null;
     }
 
+    public Status direct_insert(String key, String value) {
+
+        return Status.OK;
+    }
+
+    public Status direct_read(String key){
+
+        return Status.OK;
+    }
+
+    public Status direct_update(String key, String value){
+
+        return Status.OK;
+    }
+
+    public Status direct_delete(String key){
+
+        return Status.OK;
+    }
+
     //Insert data
     @Override
     public Status insert(String key, String value) {
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># ChulWoo\r\n\r\n# Previous Version <<MalleDB>>\r\n1. MalleDB also supports MySQL for storing Meta data and actual Key-Value data.\r\n2. MalleDB also supports MySQL for storing Meta data and Leveldb for actual Key-Value data.\r\n3. MalleDB also supports MySQL for storing Meta data and Cassandra for actual Key-Value data.\r\n\r\n## In MalleDBv1.0 We Added the following functionalities.\r\n\r\n1. MalleDB using the leveldb for storing Meta data and actual Key-Value data.\r\n\r\n2. When Deleting Key-Value Data for given file, It will delete all corresponding values from DB.\r\n\r\n3. MalleDB also supports radis and leveldb for storing Meta data and actual Key-Value data. (+ pipelining)\r\n\r\n4. MalleDb supports File, MetaFile Insert, Read, Update, Delete.\r\n\r\n* Issue 1. when MalleDB supports Cassandra for storing Meta data and actual Key-Value data.\r\n\r\n* Issue 2. Adding the Insert, Update, Delete, Read based on the original Leveldb, Cassandra DB in MalleDB.\r\n\r\n\r\n## [Docker Hub](https://hub.docker.com/r/lambent41/iesl-project)\r\n\r\nsudo apt update\r\n\r\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\r\n\r\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\r\n\r\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\"\r\n\r\nsudo apt update\r\n\r\napt-cache policy docker-ce\r\n\r\nsudo apt install docker-ce\r\n\r\n# For Building Docker Image\r\n\r\n- At the same directory with Dockerfile, to build an image as hello:0.1\r\n\r\nsudo docker build --tag hello:0.1 .\r\n- We can check all of images in the host by\r\n\r\nsudo docker images -a\r\n\r\n# For Pulling Images from Docker Hub\r\n\r\ndocker pull lambent41/iesl-project\r\n\r\n# For Running a Container\r\ndocker run -it lambent41/iesl-project:v0.01 /bin/bash\r\n\r\n# For Compile\r\nexport JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF8\r\n\r\n# MySQL Setting\r\n\r\nsudo mysql -u root\r\n\r\nmysql> create user iesl@localhost identified by '12345678';\r\n\r\nmysql> grant all privileges on *.* to 'iesl'@'localhost';\r\n\r\nmysql> create database malledb;\r\n\r\n# Jedis Implemntation\r\n\r\nhttps://mvnrepository.com/artifact/redis.clients/jedis/3.5.1\r\n\r\nGet .jar file from link above and add dependency using IntelliJ.\r\n\r\nimport redis.clients.jedis.Jedis;\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 0db4d065d62a065d831221942b5be5d6910a7d20)
+++ b/README.md	(date 1613711642843)
@@ -7,9 +7,9 @@
 
 ## In MalleDBv1.0 We Added the following functionalities.
 
-1. MalleDB using the leveldb for storing Meta data and actual Key-Value data.
+1. MalleDB using the redis and leveldb for storing Meta data and actual Key-Value data.
 
-2. When Deleting Key-Value Data for given file, It will delete all corresponding values from DB.
+2. When Deleting Key-Value Data for given file, It will delete all corresponding values from DB. (+ pipelining)
 
 3. MalleDB also supports radis and leveldb for storing Meta data and actual Key-Value data. (+ pipelining)
 
@@ -19,6 +19,17 @@
 
 * Issue 2. Adding the Insert, Update, Delete, Read based on the original Leveldb, Cassandra DB in MalleDB.
 
+* Issue 3. Redis Transaction Problem.
+
+* Issue 4. Partial Updates to MalleDB Needed.
+
+* Issue 5. API Insert/Read for big Data in MalleDB.
+
+* Issue 6. Adding Rational Query Execute/ExcuteAll/Select functionality for MySQL DB.
+
+* Issue 7. Updating MySQL to PostgreSQL DB.
+
+NOTICE : We need to add the testing file for all functionality.
 
 ## [Docker Hub](https://hub.docker.com/r/lambent41/iesl-project)
 
Index: ../filestream/src/main/java/filestream.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.io.*;\r\n\r\npublic class filestream {\r\n    public static void main(String[] args){\r\n\r\n        try{\r\n            FileInputStream fis = new FileInputStream(\"src/testfile.txt\");\r\n            FileOutputStream fos = new FileOutputStream(\"output.txt\");\r\n\r\n            BufferedInputStream bis = new BufferedInputStream(fis);\r\n            BufferedOutputStream bos = new BufferedOutputStream(fos, 100);\r\n            byte[] buffer = new byte[100];\r\n            int size = bis.read(buffer);\r\n            System.out.println(size);\r\n            bos.write(buffer, 0, size);\r\n            bos.flush();\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../filestream/src/main/java/filestream.java b/../filestream/src/main/java/filestream.java
--- a/../filestream/src/main/java/filestream.java	(revision 0db4d065d62a065d831221942b5be5d6910a7d20)
+++ b/../filestream/src/main/java/filestream.java	(date 1613706900572)
@@ -20,4 +20,5 @@
             e.printStackTrace();
         }
     }
+
 }
